{
  "updatedAt": "2025-11-23T21:23:57.000Z",
  "createdAt": "2025-10-16T23:15:45.583Z",
  "id": "7vcjG51SdGRjGJbx",
  "name": "SHADOWNING-MAIN",
  "description": null,
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -240,
        -48
      ],
      "id": "12695a2f-a310-43a4-9f95-e5001a8f3390",
      "name": "START"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "Hg91NZVyqdB46nko",
          "mode": "list",
          "cachedResultUrl": "/workflow/Hg91NZVyqdB46nko",
          "cachedResultName": "@MAIN_TEXT_GENERATION"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "duration": "={{ $('START').item.json.duration }}",
            "theme": "={{ $('START').item.json.theme }}",
            "level": "={{ $('START').item.json.level }}",
            "mode": "={{ $('START').item.json.mode }}",
            "imageStyle": "={{ $('START').item.json.imageStyle }}",
            "scenes": "={{ $('START').item.json.scenes }}",
            "targetWordsPerParagraph": "={{ $('START').item.json.targetWordsPerParagraph }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "theme",
              "displayName": "theme",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "duration",
              "displayName": "duration",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "level",
              "displayName": "level",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "mode",
              "displayName": "mode",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "imageStyle",
              "displayName": "imageStyle",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "scenes",
              "displayName": "scenes",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "targetWordsPerParagraph",
              "displayName": "targetWordsPerParagraph",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        320,
        -48
      ],
      "id": "c695bc88-d3cf-47d8-a0eb-b96610c27675",
      "name": "@CONTENT_GENERATION"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        784,
        256
      ],
      "id": "8a03e1e1-fa2d-4bed-beb6-b3c2ebee189b",
      "name": "Loop Over Content"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "VdmO0DZ3i6iBFRiU",
          "mode": "list",
          "cachedResultUrl": "/workflow/VdmO0DZ3i6iBFRiU",
          "cachedResultName": "@GLOBAL_SHADOWING"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {}
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -64,
        -48
      ],
      "id": "73780dbf-e030-45b8-93e0-f401cb3a0dd3",
      "name": "@GLOBAL_SHADOWING"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "sWBnl4vvj9HqqkTW",
          "mode": "list",
          "cachedResultUrl": "/workflow/sWBnl4vvj9HqqkTW",
          "cachedResultName": "@SCENE_METADATA_MAPPER"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "index": "={{ $('@FORMAT_TEXT_GENERATION').item.json.index }}",
            "paragraphs": "={{ $('@FORMAT_TEXT_GENERATION').item.json.paragraphs }}",
            "CHANNEL_NAME": "={{ $('@GLOBAL_SHADOWING').item.json.CHANNEL_NAME }}",
            "videoId": "={{ $('Get videoId from timestamp').item.json.videoId }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "index",
              "displayName": "index",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "paragraphs",
              "displayName": "paragraphs",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            },
            {
              "id": "videoId",
              "displayName": "videoId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "CHANNEL_NAME",
              "displayName": "CHANNEL_NAME",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        976,
        240
      ],
      "id": "ba0edc34-0978-4d93-921d-4a822649c8d9",
      "name": "@SCENE_METADATA_MAPPER"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "oq7OLyzGiJ4wzEZd",
          "mode": "list",
          "cachedResultUrl": "/workflow/oq7OLyzGiJ4wzEZd",
          "cachedResultName": "@CONTENT_SHADOWING_GENERATOR"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "index": "={{ $('Loop Over Content').first().json.index }}",
            "description": "={{ $('Loop Over Content').first().json.description }}",
            "paragraphs": "={{ $('Loop Over Content').first().json.paragraphs }}",
            "videoId": "={{ $('Get videoId from timestamp').item.json.videoId }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "videoId",
              "displayName": "videoId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "index",
              "displayName": "index",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "description",
              "displayName": "description",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "paragraphs",
              "displayName": "paragraphs",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -176,
        -416
      ],
      "id": "d2e9e437-fef3-4aa7-84dc-3285d3fca2aa",
      "name": "@CONTENT_SHADOWING_GENERATOR",
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "31b61ecd-ff5c-4148-9f62-7490b04395ca",
              "name": "videoId",
              "value": "={{new Date().toDateTime().toMillis()}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        128,
        -48
      ],
      "id": "1d9012fa-d14b-4840-9e74-a68aaec1ade9",
      "name": "Get videoId from timestamp"
    },
    {
      "parameters": {
        "command": "=set -Eeuo pipefail\n\n############# CONFIG #############\n# Como a imagem deve se ajustar ao canvas: contain | cover | stretch\nSCALE_MODE=\"${SCALE_MODE:-stretch}\"\n# ...\n\n# => PAISAGEM (deitado)\nCANVAS_W=1920\nCANVAS_H=1080\n\nBG_COLOR=\"black\"\nTEXT_COLOR=\"white\"\n\n# Para texto com QUEBRA automática, uso de legendas ASS (libass)\nFONT_FILE=\"/home/node/assets/COMMON/fonts/impact.ttf\"\nFONT_NAME=\"${FONT_NAME:-Impact}\"   # Nome da fonte usada no .ass (libass usa NOME, não o caminho)\nFONT_SIZE=96\n\nSAFE_MARGIN=96     # margens (px) esquerda/direita/superior/inferior\nFADE_SEC=0.50     # usado só no xfade de cena (imagem->imagem)\nX_PAUSE_SEC=2.5\nSCENE_CARD_SEC=1.2\nSCENE_XFADE_SEC=0.6\nSHOW_SCENE_CARDS=0\nSCENE_CARD_TEXT_PREFIX=\"Scene\"\n\n# >>> ÚNICA ALTERAÇÃO: mensagem configurável da pausa curta\nPREPARE_MSG=\"${PREPARE_MSG:-\"Get ready. Repeat right after.\"}\"\n\nX264_PRESET=\"veryfast\"\nX264_CRF=21\nAUDIO_BR=\"160k\"\n##################################\n\nWAVEFORM_MODE=\"${WAVEFORM_MODE:-bar}\"     # bar | line\nWAVEFORM_WIDTH_PCT=\"${WAVEFORM_WIDTH_PCT:-50}\"  # % da largura do canvas\nWAVEFORM_HEIGHT=\"${WAVEFORM_HEIGHT:-160}\"       # altura em px\nWAVEFORM_OPACITY=\"${WAVEFORM_OPACITY:-0.30}\"    # 0.0–1.0 (30% por padrão)\nWAVEFORM_MARGIN_BOTTOM=\"${WAVEFORM_MARGIN_BOTTOM:-10}\"  # distância do rodapé (px)\nWAVEFORM_ENABLE=\"${WAVEFORM_ENABLE:-1}\"         # 1 liga, 0 desliga\n\n\n# Workdir temporário\nTMPROOT=\"/home/node/download\"\nmkdir -p \"$TMPROOT\"\nTMPDIR=\"$(mktemp -d \"$TMPROOT/.shadow_XXXXXX\")\"\ntrap 'rm -rf \"$TMPDIR\"' EXIT\n\nLIST=\"$TMPDIR/list.txt\"; : > \"$LIST\"\n\n# Fonte fallback (para bg quando não houver imagem) + nome correto para libass\nif [ ! -f \"$FONT_FILE\" ]; then\n  if   [ -f \"/home/node/assets/COMMON/fonts/impact.ttf\" ]; then\n    FONT_FILE=\"/home/node/assets/COMMON/fonts/impact.ttf\"\n    FONT_NAME=\"Impact\"\n  elif [ -f \"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\" ]; then\n    FONT_FILE=\"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\"\n    FONT_NAME=\"DejaVu Sans\"\n  fi\nfi\n\n# Diretório da fonte (para libass localizar pelo nome)\nFONT_DIR=\"$(dirname \"$FONT_FILE\")\"\n\n# =========== Entrada JSON (todos os itens do nó anterior) ===========\nIN_JSON=\"$TMPDIR/in.json\"\ncat > \"$IN_JSON\" <<'JSON'\n{{ JSON.stringify($input.all().map(i => i.json)) }}\nJSON\n\nif [ ! -s \"$IN_JSON\" ]; then\n  echo \"ERRO: Entrada JSON vazia. Garanta que este nó recebe o array do nó anterior e Execute Once = ON.\"\n  exit 1\nfi\n\n# ==================== FUNÇÕES ====================\nprobe_dur () { ffprobe -hide_banner -loglevel error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 \"$1\" 2>/dev/null | tr -d '\\r' || true; }\n\nscale_to_canvas () {\n  case \"$SCALE_MODE\" in\n    cover)\n      echo \"scale=${CANVAS_W}:${CANVAS_H}:force_original_aspect_ratio=increase,crop=${CANVAS_W}:${CANVAS_H}\"\n      ;;\n    stretch)\n      echo \"scale=${CANVAS_W}:${CANVAS_H}\"\n      ;;\n    *)\n      echo \"scale=${CANVAS_W}:${CANVAS_H}:force_original_aspect_ratio=decrease,pad=${CANVAS_W}:${CANVAS_H}:(ow-iw)/2:(oh-ih)/2:color=${BG_COLOR}\"\n      ;;\n  esac\n}\n\n# Gera um .ass centralizado (Alignment 5), wrap automático e SEM espaçamento entre letras\nmake_ass_file () { # $1: caminho .ass ; $2: texto\n  local ASS=\"$1\" RAW=\"$2\"\n  local TXT\n  TXT=\"$(printf '%s' \"$RAW\" | sed -e 's/[{}]/()/g' -e 's/\\\\/\\\\\\\\/g')\"\n\n  cat > \"$ASS\" <<EOF\n[Script Info]\nScriptType: v4.00+\nPlayResX: ${CANVAS_W}\nPlayResY: ${CANVAS_H}\nScaledBorderAndShadow: yes\nWrapStyle: 0\n\n[V4+ Styles]\n; Spacing=0 (sem espaçamento de letras). Outline para legibilidade.\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Default, ${FONT_NAME}, ${FONT_SIZE}, &H00000000, &H000000FF, &H66FFFFFF, &H7F000000, 0, 0, 0, 0, 100, 100, 0, 0, 1, 1.2, 0.6, 5, ${SAFE_MARGIN}, ${SAFE_MARGIN}, ${SAFE_MARGIN}, 0\n\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\nDialogue: 0,0:00:00.00,9:59:59.99,Default,,0000,0000,0000,,${TXT}\nEOF\n}\n\n# BG puro (sem fade — fade só quando troca IMAGEM)\nmake_bg_clip () { # $1 IMG, $2 OUT, $3 DUR\n  local IMG=\"$1\" OUT=\"$2\" DUR=\"$3\"\n  if [ -n \"${IMG:-}\" ] && [ -f \"$IMG\" ]; then\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n      -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"[0:v]$(scale_to_canvas),fps=30,format=yuv420p,setsar=1[v];[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n      -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  else\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n      -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"[0:v]format=yuv420p,setsar=1[v];[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n      -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  fi\n}\n\nmake_text_over_audio () { # $1 SRC, $2 OUT, $3 TXT, $4 IMG\n  local SRC=\"$1\" OUT=\"$2\" TXT=\"$3\" IMG=\"$4\" DUR ASSF\n  DUR=$(probe_dur \"$SRC\"); [ -z \"$DUR\" ] && DUR=0\n  ASSF=\"$OUT.ass\"; make_ass_file \"$ASSF\" \"$TXT\"\n\n  # Dimensões base do waveform (ex.: 50% da largura, altura configurável)\n  local WF_W=$(( CANVAS_W * ${WAVEFORM_WIDTH_PCT:-50} / 100 ))\n  local WF_H=${WAVEFORM_HEIGHT:-160}\n\n  # Mapear 'bar' -> 'line' (showwaves não tem 'bar'); engrossar a linha por multiplicação de altura\n  local REQ_MODE=\"${WAVEFORM_MODE:-bar}\"\n  local SW_MODE=\"line\"\n  local THICK_MUL=2\n  if [ \"$REQ_MODE\" = \"bar\" ]; then\n    SW_MODE=\"line\"     # simula barras com linha engrossada\n    THICK_MUL=3\n  elif [ \"$REQ_MODE\" = \"p2p\" ] || [ \"$REQ_MODE\" = \"point\" ] || [ \"$REQ_MODE\" = \"line\" ]; then\n    SW_MODE=\"$REQ_MODE\"\n  else\n    SW_MODE=\"line\"\n  fi\n\n  # Gera mais alto e reduz para WF_H para engrossar\n  local WF_HI=$(( WF_H * THICK_MUL ))\n\n  # Cadeia: showwaves (branco) -> RGBA -> remove fundo preto -> reescala p/ engrossar -> recolore p/ preto + alpha\n  # Assim obtemos waveform PRETO sem retângulo, com ~30% opacidade.\n  local WF_CHAIN=\"[0:a]showwaves=s=${WF_W}x${WF_HI}:mode=${SW_MODE}:colors=white,format=rgba,colorkey=black:similarity=0.01:blend=0,scale=${WF_W}x${WF_H},colorchannelmixer=rr=0:gg=0:bb=0:aa=${WAVEFORM_OPACITY:-0.30}[wv];\"\n\n  # Posição final: centralizado; base a 10 px do rodapé\n  local OVERLAY_EXPR=\"x=(W-w)/2:y=H-${WAVEFORM_MARGIN_BOTTOM:-10}-h\"\n\n  if [ -n \"${IMG:-}\" ] && [ -f \"$IMG\" ]; then\n    if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n        -filter_complex \"\\\n[1:v]$(scale_to_canvas)[bg];\\\n[bg]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR}[txt];\\\n${WF_CHAIN}\\\n[txt][wv]overlay=${OVERLAY_EXPR},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    else\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n        -filter_complex \"\\\n[1:v]$(scale_to_canvas)[bg];\\\n[bg]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    fi\n  else\n    if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n        -filter_complex \"\\\n[1:v]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR}[bg];\\\n${WF_CHAIN}\\\n[bg][wv]overlay=${OVERLAY_EXPR},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    else\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n        -filter_complex \"\\\n[1:v]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    fi\n  fi\n}\n\n\n# Silêncio + Texto (SEM fade quando só muda o texto)\nmake_silence_with_text () { # $1 OUT, $2 DUR, $3 TXT, $4 IMG\n  local OUT=\"$1\" DUR=\"$2\" TXT=\"$3\" IMG=\"$4\" ASSF\n  ASSF=\"$OUT.ass\"; make_ass_file \"$ASSF\" \"$TXT\"\n\n  if [ -n \"${IMG:-}\" ] && [ -f \"$IMG\" ]; then\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -loop 1 -t \"$DUR\" -i \"$IMG\" -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"[0:v]$(scale_to_canvas)[bg];[bg]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},format=yuv420p,fps=30,setsar=1[v];[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n      -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  else\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"[0:v]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},format=yuv420p,fps=30,setsar=1[v];[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n      -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  fi\n}\n\n# XFADE ENTRE IMAGENS (apenas quando muda de cena)\nmake_scene_xfade () { # $1 P, $2 N, $3 OUT, $4 DUR\n  local P=\"$1\" N=\"$2\" OUT=\"$3\" DUR=\"$4\"\n  if [ -n \"${P:-}\" ] && [ -f \"$P\" ] && [ -n \"${N:-}\" ] && [ -f \"$N\" ]; then\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -loop 1 -t \"$DUR\" -i \"$P\" -loop 1 -t \"$DUR\" -i \"$N\" -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"[0:v]$(scale_to_canvas)[a0];[1:v]$(scale_to_canvas)[a1];[a0][a1]xfade=transition=fade:duration=${DUR}:offset=0,format=yuv420p,setsar=1,fps=30[v];[2:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n      -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  else\n    make_bg_clip \"${P:-}\" \"$OUT\" \"$DUR\"\n  fi\n}\n\n# =========== Constrói TSV a partir do JSON ===========\nBUILD_JS=\"$TMPDIR/build.js\"\ncat > \"$BUILD_JS\" <<'JS'\nconst fs = require('fs');\n\nconst path = process.argv[2] || process.argv[1];\nif (!path) { console.error('sem caminho JSON'); process.exit(1); }\n\nlet arr;\ntry { arr = JSON.parse(fs.readFileSync(path, 'utf8')); }\ncatch(e){ console.error('JSON inválido:', e.message); process.exit(2); }\n\nif (!Array.isArray(arr) || !arr.length) { console.error('JSON vazio'); process.exit(3); }\n\nconst ch  = arr[0].CHANNEL_NAME || 'CANAL_SHADOWING';\nconst vid = arr[0].videoId || String(Date.now());\n\nconsole.log(`#DEST_DIR=/home/node/download/${ch}/${vid}`);\nconsole.log(`#FINAL_OUT=/home/node/download/${ch}/${vid}/shadow_${Date.now()}.mp4`);\n\nfunction exists(p){ try{ fs.accessSync(p); return true; }catch{ return false; } }\n\nfor (const it of arr) {\n  const scene = it.sceneId ?? 0;\n  const audio = it.videoMetaData?.file || '';\n  const text  = String(it.audioSubtitle ?? '').replace(/\\r?\\n/g,' ');\n  const baseCh = it.CHANNEL_NAME || ch;\n  const baseVid= it.videoId || vid;\n  const guess  = `/home/node/download/${baseCh}/${baseVid}/${scene}_${baseVid}.png`;\n  const img    = exists(guess) ? guess : '';\n  console.log([audio, text, scene, img].join('|'));\n}\nJS\n\nTSV_RAW=\"$TMPDIR/raw.tsv\"\nnode \"$BUILD_JS\" \"$IN_JSON\" > \"$TSV_RAW\"\n\nDEST_DIR=$(grep '^#DEST_DIR=' \"$TSV_RAW\" | head -n1 | cut -d'=' -f2-)\nFINAL_OUT=$(grep '^#FINAL_OUT=' \"$TSV_RAW\" | head -n1 | cut -d'=' -f2-)\n[ -z \"${DEST_DIR:-}\" ] && { echo \"Falha ao obter DEST_DIR do JSON\"; exit 1; }\nmkdir -p \"$DEST_DIR\"\n\nDATA_FILE=\"$TMPDIR/data.tsv\"\ngrep -v '^#' \"$TSV_RAW\" > \"$DATA_FILE\"\n\n# ============== Loop principal =================\nlast_scene=\"\"; last_img=\"\"; idx=0; read_first_line=1\n\nexec 9< \"$DATA_FILE\"\nwhile IFS='|' read -r -u 9 SRC TXT SCENE IMG; do\n  [ -z \"${SRC:-}\" ] && continue\n  DUR=$(probe_dur \"$SRC\"); [ -z \"$DUR\" ] && DUR=0\n\n  # XFADE somente quando a IMAGEM muda (mudança de cena)\n  if [ \"$read_first_line\" -eq 0 ] && [ \"$SCENE\" != \"$last_scene\" ]; then\n    XF=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_xfade_${last_scene}_${SCENE}.mp4\"\n    make_scene_xfade \"$last_img\" \"$IMG\" \"$XF\" \"$SCENE_XFADE_SEC\"\n    printf \"file '%s'\\n\" \"$XF\" >> \"$LIST\"; idx=$((idx+1))\n  fi\n\n  # card opcional de cena (também sem fade)\n  if [ \"$SHOW_SCENE_CARDS\" -eq 1 ] && { [ \"$read_first_line\" -eq 1 ] || [ \"$SCENE\" != \"$last_scene\" ]; }; then\n    CARD=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_scene_${SCENE}.mp4\"\n    make_silence_with_text \"$CARD\" \"$SCENE_CARD_SEC\" \"${SCENE_CARD_TEXT_PREFIX} ${SCENE}\" \"$IMG\"\n    printf \"file '%s'\\n\" \"$CARD\" >> \"$LIST\"; idx=$((idx+1))\n  fi\n\n  read_first_line=0; last_scene=\"$SCENE\"; last_img=\"$IMG\"\n\n  ###############################################\n  # MUDANÇA: cena 0 SEM repetições/pausas\n  ###############################################\n  if [ \"$SCENE\" -eq 0 ]; then\n    # Apenas 1x play com texto sobre o áudio\n    P1=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_play_s${SCENE}.mp4\"\n    make_text_over_audio \"$SRC\" \"$P1\" \"$TXT\" \"$IMG\"\n    printf \"file '%s'\\n\" \"$P1\" >> \"$LIST\"; idx=$((idx+1))\n  else\n    # Padrão antigo (3 passes + pausas)\n    # 1) play\n    P1=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_play1_s${SCENE}.mp4\"\n    make_text_over_audio \"$SRC\" \"$P1\" \"$TXT\" \"$IMG\"\n    printf \"file '%s'\\n\" \"$P1\" >> \"$LIST\"; idx=$((idx+1))\n\n    # 2) pausa curta (mensagem PREPARE_MSG)\n    PX=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_pauseX_s${SCENE}.mp4\"\n    make_silence_with_text \"$PX\" \"$X_PAUSE_SEC\" \"$PREPARE_MSG\" \"$IMG\"\n    printf \"file '%s'\\n\" \"$PX\" >> \"$LIST\"; idx=$((idx+1))\n\n    # 3) pausa do tamanho do áudio\n    PY=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_pauseY_s${SCENE}.mp4\"\n    make_silence_with_text \"$PY\" \"$DUR\" \"$TXT\" \"$IMG\"\n    printf \"file '%s'\\n\" \"$PY\" >> \"$LIST\"; idx=$((idx+1))\n\n    # 4) replay\n    P3=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_play3_s${SCENE}.mp4\"\n    make_text_over_audio \"$SRC\" \"$P3\" \"$TXT\" \"$IMG\"\n    printf \"file '%s'\\n\" \"$P3\" >> \"$LIST\"; idx=$((idx+1))\n  fi\ndone\nexec 9<&-\n\n# ============== Concat final ====================\nffmpeg -nostdin -hide_banner -loglevel error -y -f concat -safe 0 -i \"$LIST\" -c copy -movflags +faststart \"$FINAL_OUT\"\necho \"OK: $FINAL_OUT\"\n"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        16,
        -416
      ],
      "id": "bfe467c6-73b0-4e30-a0c1-89bc6f025681",
      "name": "Execute Command with OpenAI image"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "dWYPzcYBySisGRMl",
          "mode": "list",
          "cachedResultUrl": "/workflow/dWYPzcYBySisGRMl",
          "cachedResultName": "@CONTENT_SHADOWING_GENERATOR_WITHOUT_IMAGE"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "index": "={{ $('Loop Over Content').item.json.index }}",
            "paragraphs": "={{ $('Loop Over Content').item.json.paragraphs }}",
            "videoId": "={{ $('Get videoId from timestamp').item.json.videoId }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "videoId",
              "displayName": "videoId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "index",
              "displayName": "index",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "paragraphs",
              "displayName": "paragraphs",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "array",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        976,
        448
      ],
      "id": "388efcf4-fd8d-425f-9853-ab96439299c2",
      "name": "@CONTENT_SHADOWING_GENERATOR_WITHOUT_IMAGES"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "r12Z7cpPLhCgVVRI",
          "mode": "list",
          "cachedResultUrl": "/workflow/r12Z7cpPLhCgVVRI",
          "cachedResultName": "@FORMAT_TEXT_GENERATION"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "scenes": "={{ $('START').item.json.scenes }}",
            "targetWordsPerParagraph": "={{ $('START').item.json.targetWordsPerParagraph }}",
            "rawText": "={{ $json.output }}",
            "imageStyle": "={{ $('START').item.json.imageStyle }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "rawText",
              "displayName": "rawText",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "imageStyle",
              "displayName": "imageStyle",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "scenes",
              "displayName": "scenes",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            },
            {
              "id": "targetWordsPerParagraph",
              "displayName": "targetWordsPerParagraph",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "number",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        576,
        256
      ],
      "id": "0eee1867-5396-40c7-865c-cb8cfabc2344",
      "name": "@FORMAT_TEXT_GENERATION"
    },
    {
      "parameters": {
        "content": "## Version with background",
        "height": 304,
        "width": 448
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -240,
        -496
      ],
      "id": "d3f22ac8-43f0-4af5-bcf2-cfa16a077dc3",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "3sxWSvgWXjPihECD",
          "mode": "list",
          "cachedResultUrl": "/workflow/3sxWSvgWXjPihECD",
          "cachedResultName": "@YOUTUBE_DATA_CONTENT"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "theme": "={{ $('START').item.json.theme }}",
            "videoMode": "={{ $('START').item.json.mode }}",
            "videoContent": "={{ $('@CONTENT_GENERATION').item.json.output }}",
            "level": "={{ $('START').item.json.level }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "theme",
              "displayName": "theme",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "videoContent",
              "displayName": "videoContent",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "videoMode",
              "displayName": "videoMode",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "level",
              "displayName": "level",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        576,
        80
      ],
      "id": "1f62dcd4-fcdf-4a0f-ac19-2607415c2ea0",
      "name": "@YOUTUBE_DATA_CONTENT"
    },
    {
      "parameters": {
        "numberInputs": 4
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1456,
        64
      ],
      "id": "b407126d-447a-4b7e-9d68-5086f64e408d",
      "name": "Merge"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "wDmJOKsJMEGVwOLL",
          "mode": "list",
          "cachedResultUrl": "/workflow/wDmJOKsJMEGVwOLL",
          "cachedResultName": "@UPLOAD_YOUTUBE_SHADOWING"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "videoId": "={{ $('Get videoId from timestamp').item.json.videoId }}",
            "CHANNEL_NAME": "={{ $('@GLOBAL_SHADOWING').item.json.CHANNEL_NAME }}",
            "output_VideoTitle": "={{ $('Aggregate').item.json.output.last().VideoTitle }}",
            "output_VideoDescription": "={{ $('Aggregate').item.json.output.last().VideoDescription }}",
            "output_Tags_map": "={{ $('Aggregate').item.json.output.last().Tags.map(a => a) }}",
            "output_Study_Material": "={{ $('@STUDY_CONTENT_MATERIAL').item.json.ContentLink }}"
          },
          "matchingColumns": [
            "videoId",
            "CHANNEL_NAME",
            "output_VideoTitle",
            "output_VideoDescription",
            "output_Tags_map"
          ],
          "schema": [
            {
              "id": "videoId",
              "displayName": "videoId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "CHANNEL_NAME",
              "displayName": "CHANNEL_NAME",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output_VideoTitle",
              "displayName": "output_VideoTitle",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output_VideoDescription",
              "displayName": "output_VideoDescription",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output_Tags_map",
              "displayName": "output_Tags_map",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output_Study_Material",
              "displayName": "output_Study_Material",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1840,
        96
      ],
      "name": "@UPLOAD_YOUTUBE_SHADOWING",
      "id": "5303ad5a-e0b5-47b1-8e49-7ddcc0f485cf"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        784,
        -32
      ],
      "id": "23ed7170-d186-4fe2-94f8-7d10d47f8918",
      "name": "Merge1"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "zhj5BKdTM2K8HPaE",
          "mode": "list",
          "cachedResultUrl": "/workflow/zhj5BKdTM2K8HPaE",
          "cachedResultName": "@SHADOWING-THUMBNAIL-CREATOR"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "output_thumbnailText_join": "={{ $('Merge1').item.json.output.thumbnailText.join() }}",
            "output_VideoDescription": "={{ $('Merge1').item.json.output.VideoDescription }}",
            "output": "={{ $('@CONTENT_GENERATION').item.json.output }}",
            "output_VideoTitle": "={{ $('Merge1').item.json.output.VideoTitle }}",
            "videoId": "={{ $('Get videoId from timestamp').item.json.videoId }}",
            "CHANNEL_NAME": "={{ $('@GLOBAL_SHADOWING').item.json.CHANNEL_NAME }}"
          },
          "matchingColumns": [
            "output_thumbnailText_join",
            "output_VideoDescription",
            "output",
            "output_VideoTitle",
            "videoId",
            "CHANNEL_NAME"
          ],
          "schema": [
            {
              "id": "output_thumbnailText_join",
              "displayName": "output_thumbnailText_join",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output_VideoDescription",
              "displayName": "output_VideoDescription",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output",
              "displayName": "output",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output_VideoTitle",
              "displayName": "output_VideoTitle",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "videoId",
              "displayName": "videoId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "CHANNEL_NAME",
              "displayName": "CHANNEL_NAME",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        976,
        -32
      ],
      "name": "@SHADOWING-THUMBNAIL-CREATOR",
      "id": "25134342-e8bc-4f7b-98f8-30da1237e2bd"
    },
    {
      "parameters": {
        "command": "=#!/usr/bin/env bash\nset -Eeuo pipefail\n\n############# CONFIG #############\n# Como a imagem deve se ajustar ao canvas: contain | cover | stretch\nSCALE_MODE=\"${SCALE_MODE:-stretch}\"\n\n# LAYOUT (paisagem)\nCANVAS_W=1920\nCANVAS_H=1080\n\nBG_COLOR=\"black\"\n\n# Texto (libass): Impact do diretório COMMON/fonts\nFONT_ROOT=\"/home/node/assets/COMMON/fonts\"   # <- atenção: \"node\" (sem 's')\nFONT_FILE=\"${FONT_FILE:-$FONT_ROOT/impact.ttf}\"\nFONT_NAME=\"${FONT_NAME:-Impact}\"\nFONT_SIZE=${FONT_SIZE:-72}\nSAFE_MARGIN=${SAFE_MARGIN:-72}\n\n# Knobs de espessura do contorno/sombra (pode ajustar por env)\nTEXT_OUTLINE=\"${TEXT_OUTLINE:-0.6}\"   # 0.8–1.2 deixa fino/crisp\nTEXT_SHADOW=\"${TEXT_SHADOW:-0.12}\"     # 0–0.5; 0 = sem sombra\n\n# Fades nas bordas de cada clipe (além do xfade entre cenas)\nEDGE_FADE_SEC=\"${EDGE_FADE_SEC:-0.25}\"    # vídeo (in/out)\nAUDIO_FADE_SEC=\"${AUDIO_FADE_SEC:-0.12}\"  # audio (in/out)\n\n# Encoder\nX264_PRESET=\"${X264_PRESET:-veryfast}\"\nX264_CRF=${X264_CRF:-21}\nAUDIO_BR=\"${AUDIO_BR:-160k}\"\n\n# Waveform (quando houver áudio)\nWAVEFORM_ENABLE=\"${WAVEFORM_ENABLE:-1}\"        # 1 liga, 0 desliga\nWAVEFORM_WIDTH_PCT=\"${WAVEFORM_WIDTH_PCT:-60}\" # 60% da largura\nWAVEFORM_HEIGHT=\"${WAVEFORM_HEIGHT:-200}\"      # px\nWAVEFORM_OPACITY=\"${WAVEFORM_OPACITY:-0.95}\"   # 0–1 (quase sólida)\nWAVEFORM_MARGIN_BOTTOM=\"${WAVEFORM_MARGIN_BOTTOM:-12}\"  # px do rodapé\nWAVEFORM_MODE=\"${WAVEFORM_MODE:-bar}\"          # \"bar\" simulado engrossando a linha\n\n# Barra de progresso countdown (fase REPEAT)\nCOUNTDOWN_ENABLE=\"${COUNTDOWN_ENABLE:-1}\"           # 1 liga, 0 desliga\nCOUNTDOWN_HEIGHT=\"${COUNTDOWN_HEIGHT:-20}\"          # altura da barra em px\nCOUNTDOWN_MARGIN_BOTTOM=\"${COUNTDOWN_MARGIN_BOTTOM:-50}\"  # distância do rodapé\nCOUNTDOWN_COLOR=\"${COUNTDOWN_COLOR:-FFFFFF}\"        # cor em hex (branca: FFFFFF)\nCOUNTDOWN_BG_COLOR=\"${COUNTDOWN_BG_COLOR:-333333}\"  # fundo da barra (cinza escuro)\n\n# Backgrounds (ciclo fixo por cena)\nBASE_BG_DIR=\"/home/node/assets/CANAL_SHADOWING\"\nLISTEN_IMG=\"${BASE_BG_DIR}/listen01.png\"\nREPEAT_IMG=\"${BASE_BG_DIR}/repeat01.png\"\nTOGETHER_IMG=\"${BASE_BG_DIR}/talk-together01.png\"\nSCENE_XFADE_SEC=\"${SCENE_XFADE_SEC:-0.6}\"\n##################################\n\n# ============ VARS DINÂMICAS DO n8n ============\nVIDEO_ID=\"{{ $('Get videoId from timestamp').item.json.videoId || $json.videoId || Date.now() }}\"\nCHANNEL_NAME=\"{{ $json.CHANNEL_NAME || 'CANAL_SHADOWING' }}\"\nexport VIDEO_ID CHANNEL_NAME\n# ==============================================\n\n# Workdir temporário\nTMPROOT=\"/home/node/download\"\nmkdir -p \"$TMPROOT\"\nTMPDIR=\"$(mktemp -d \"$TMPROOT/.shadow_XXXXXX\")\"\ntrap 'rm -rf \"$TMPDIR\"' EXIT\n\nLIST=\"$TMPDIR/list.txt\"; : > \"$LIST\"\n\n# Garante Impact do diretório pedido (case-insensitive + otf)\nif [ ! -f \"$FONT_FILE\" ]; then\n  if   [ -f \"$FONT_ROOT/impact.ttf\" ]; then FONT_FILE=\"$FONT_ROOT/impact.ttf\"\n  elif [ -f \"$FONT_ROOT/Impact.ttf\" ]; then FONT_FILE=\"$FONT_ROOT/Impact.ttf\"\n  elif [ -f \"$FONT_ROOT/Impact.otf\" ]; then FONT_FILE=\"$FONT_ROOT/Impact.otf\"\n  fi\nfi\nFONT_DIR=\"$(dirname \"$FONT_FILE\")\"\n\n# Descobre o \"family name\" interno do arquivo de fonte para evitar fallback\nif command -v fc-scan >/dev/null 2>&1; then\n  INTERNAL_NAME=\"$(fc-scan --format='%{family}\\n' \"$FONT_FILE\" 2>/dev/null | head -n1 || true)\"\n  if [ -n \"$INTERNAL_NAME\" ]; then\n    FONT_NAME=\"$INTERNAL_NAME\"\n  fi\nfi\n\n# ===== utils: números com 3 casas (awk) =====\nclamp_start () {\n  # $1 = DUR, $2 = fade_sec\n  awk -v d=\"$1\" -v f=\"$2\" 'BEGIN{ s=d-f; if (s<0) s=0; printf \"%.3f\", s }'\n}\n\n# =========== Entrada JSON (do node anterior) ===========\nIN_JSON=\"$TMPDIR/in.json\"\ncat > \"$IN_JSON\" <<'JSON'\n{{ JSON.stringify($input.all().map(i => i.json)) }}\nJSON\n[ -s \"$IN_JSON\" ] || { echo \"ERRO: Entrada JSON vazia\"; exit 1; }\n\n# ==================== FUNÇÕES ====================\nprobe_dur () { ffprobe -hide_banner -loglevel error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 \"$1\" 2>/dev/null | tr -d '\\r' || true; }\n\nscale_to_canvas () {\n  case \"$SCALE_MODE\" in\n    cover)   echo \"scale=${CANVAS_W}:${CANVAS_H}:force_original_aspect_ratio=increase,crop=${CANVAS_W}:${CANVAS_H}\" ;;\n    stretch) echo \"scale=${CANVAS_W}:${CANVAS_H}\" ;;\n    *)       echo \"scale=${CANVAS_W}:${CANVAS_H}:force_original_aspect_ratio=decrease,pad=${CANVAS_W}:${CANVAS_H}:(ow-iw)/2:(oh-ih)/2:color=${BG_COLOR}\" ;;\n  esac\n}\n\n# .ass centralizado, wrap automático, fonte branca + contorno cinza fino\nmake_ass_file () { # $1: .ass ; $2: texto\n  local ASS=\"$1\" RAW=\"$2\" SAN TXT STYLE_OVERRIDE\n  # Sanitize do texto do usuário (preserva as chaves do override)\n  SAN=\"$(printf '%s' \"$RAW\" | sed -e 's/[{}]/()/g' -e 's/\\\\/\\\\\\\\/g')\"\n\n  # Override para garantir fonte e espessura finas\n  STYLE_OVERRIDE=\"{\\\\fn${FONT_NAME}\\\\bord${TEXT_OUTLINE}\\\\shad${TEXT_SHADOW}\\\\b0}\"\n\n  TXT=\"${STYLE_OVERRIDE}${SAN}\"\n\n  cat > \"$ASS\" <<EOF\n[Script Info]\nScriptType: v4.00+\nPlayResX: ${CANVAS_W}\nPlayResY: ${CANVAS_H}\nScaledBorderAndShadow: yes\nWrapStyle: 0\n\n[V4+ Styles]\n; Cores em ASS = &HAABBGGRR (A=alpha, BB=azul, GG=verde, RR=vermelho)\n; Primary=branco, Outline=cinza escuro (#404040), sem back/shadow pesado\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Default, ${FONT_NAME}, ${FONT_SIZE}, &H00FFFFFF, &H000000FF, &H00404040, &H00000000, 0, 0, 0, 0, 100, 100, 0, 0, 1, ${TEXT_OUTLINE}, ${TEXT_SHADOW}, 5, ${SAFE_MARGIN}, ${SAFE_MARGIN}, ${SAFE_MARGIN}, 0\n\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\nDialogue: 0,0:00:00.00,9:59:59.99,Default,,0000,0000,0000,,${TXT}\nEOF\n}\n\n\n# Texto + áudio + BG (+ waveform branco no rodapé) + fades nas bordas\nmake_text_over_audio () { # $1 SRC, $2 OUT, $3 TXT, $4 IMG (passe IMG=\"\" p/ fundo preto)\n  local SRC=\"$1\" OUT=\"$2\" TXT=\"$3\" IMG=\"$4\" DUR ASSF\n  DUR=$(probe_dur \"$SRC\"); [ -z \"$DUR\" ] && DUR=0\n  ASSF=\"$OUT.ass\"; make_ass_file \"$ASSF\" \"$TXT\"\n\n  # calcula inícios do fade-out (clampeados)\n  local VOUT_ST; VOUT_ST=$(clamp_start \"$DUR\" \"$EDGE_FADE_SEC\")\n  local AOUT_ST; AOUT_ST=$(clamp_start \"$DUR\" \"$AUDIO_FADE_SEC\")\n\n  local WF_W=$(( CANVAS_W * ${WAVEFORM_WIDTH_PCT:-60} / 100 ))\n  local WF_H=${WAVEFORM_HEIGHT:-200}\n\n  local REQ_MODE=\"${WAVEFORM_MODE:-bar}\"\n  local SW_MODE=\"line\"\n  local THICK_MUL=3\n  if [ \"$REQ_MODE\" = \"line\" ]; then THICK_MUL=1; fi\n  local WF_HI=$(( WF_H * THICK_MUL ))\n\n  local WF_CHAIN=\"\"\n  if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n    WF_CHAIN=\"[0:a]showwaves=s=${WF_W}x${WF_HI}:mode=${SW_MODE}:colors=white,format=rgba,colorkey=black:similarity=0.01:blend=0,scale=${WF_W}x${WF_H},colorchannelmixer=aa=${WAVEFORM_OPACITY:-0.95}[wv];\"\n  fi\n\n  local OVERLAY_EXPR=\"x=(W-w)/2:y=H-${WAVEFORM_MARGIN_BOTTOM:-12}-h\"\n\n  if [ -n \"${IMG:-}\" ] && [ -f \"$IMG\" ]; then\n    if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n        -filter_complex \"\\\n[1:v]$(scale_to_canvas)[bg];\\\n[bg]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR}[txt];\\\n${WF_CHAIN}\\\n[txt][wv]overlay=${OVERLAY_EXPR},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    else\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n        -filter_complex \"\\\n[1:v]$(scale_to_canvas)[bg];\\\n[bg]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    fi\n  else\n    if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n        -filter_complex \"\\\n[1:v]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR}[bg];\\\n${WF_CHAIN}\\\n[bg][wv]overlay=${OVERLAY_EXPR},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    else\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n        -filter_complex \"\\\n[1:v]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    fi\n  fi\n}\n\n# Silêncio + Texto + Barra de Progresso Countdown (animada via GEQ/alpha) + fades nas bordas (vídeo) + afade (mesmo com anullsrc)\nmake_silence_with_text () { # $1 OUT, $2 DUR, $3 TXT, $4 IMG\n  local OUT=\"$1\" DUR=\"$2\" TXT=\"$3\" IMG=\"$4\" ASSF\n  ASSF=\"$OUT.ass\"; make_ass_file \"$ASSF\" \"$TXT\"\n\n  # calcula início do fade-out (clampeado)\n  local VOUT_ST; VOUT_ST=$(clamp_start \"$DUR\" \"$EDGE_FADE_SEC\")\n  local AOUT_ST; AOUT_ST=$(clamp_start \"$DUR\" \"$AUDIO_FADE_SEC\")\n\n  # Geometria da barra\n  local BAR_H=\"${COUNTDOWN_HEIGHT:-20}\"\n  local BAR_MARGIN=\"${COUNTDOWN_MARGIN_BOTTOM:-50}\"\n  local BAR_W=$((CANVAS_W - 200))   # 100 px de margem por lado\n  local BAR_X=100\n  local BAR_Y=$((CANVAS_H - BAR_MARGIN - BAR_H))\n\n  # Barra animada (de cheia -> zero em DUR)\n  local COUNTDOWN_FILTER=\"\"\n  if [ \"${COUNTDOWN_ENABLE:-1}\" -eq 1 ]; then\n    COUNTDOWN_FILTER=\"\\\ncolor=c=white:size=${BAR_W}x${BAR_H}:rate=30:duration=${DUR},format=rgba,\\\ngeq=r='255':g='255':b='255':a='if(lte(X, W*max(1 - T/${DUR}, 0)), 255, 0)'[bar];\\\n[txt]drawbox=x=${BAR_X}:y=${BAR_Y}:w=${BAR_W}:h=${BAR_H}:color=0x${COUNTDOWN_BG_COLOR}:t=fill[txtbg];\\\n[txtbg][bar]overlay=${BAR_X}:${BAR_Y},\"\n  fi\n\n  if [ -n \"${IMG:-}\" ] && [ -f \"$IMG\" ]; then\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n      -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"\\\n[0:v]$(scale_to_canvas)[bg];\\\n[bg]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},fps=30,setpts=PTS-STARTPTS[txt];\\\n${COUNTDOWN_FILTER}\\\nfade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,setsar=1[v];\\\n[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n      -map \"[v]\" -map \"[a]\" \\\n      -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart \\\n      -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  else\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n      -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"\\\n[0:v]ass='$ASSF':shaping=1:fontsdir=${FONT_DIR},fps=30,setpts=PTS-STARTPTS[txt];\\\n${COUNTDOWN_FILTER}\\\nfade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,setsar=1[v];\\\n[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n      -map \"[v]\" -map \"[a]\" \\\n      -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart \\\n      -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  fi\n}\n\n# Xfade entre cenas (TOGETHER -> LISTEN)\nmake_scene_xfade () { # $1 P, $2 N, $3 OUT, $4 DUR\n  local P=\"$1\" N=\"$2\" OUT=\"$3\" DUR=\"$4\"\n  ffmpeg -nostdin -hide_banner -loglevel error -y \\\n    -loop 1 -t \"$DUR\" -i \"$P\" -loop 1 -t \"$DUR\" -i \"$N\" -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n    -filter_complex \"[0:v]$(scale_to_canvas)[a0];[1:v]$(scale_to_canvas)[a1];[a0][a1]xfade=transition=fade:duration=${DUR}:offset=0,format=yuv420p,setsar=1,fps=30[v];[2:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n    -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n}\n\n# ======== TSV a partir do JSON ========\nBUILD_JS=\"$TMPDIR/build.js\"\ncat > \"$BUILD_JS\" <<'JS'\nconst fs = require('fs');\nconst env = process.env;\n\nconst path = process.argv[2];\nlet arr;\ntry { arr = JSON.parse(fs.readFileSync(path, 'utf8')); }\ncatch(e){ console.error('JSON inválido:', e.message); process.exit(2); }\n\nif (!Array.isArray(arr) || !arr.length) { console.error('JSON vazio'); process.exit(3); }\n\nconst ch  = env.CHANNEL_NAME || arr[0].CHANNEL_NAME || 'CANAL_SHADOWING';\nconst vid = env.VIDEO_ID     || arr[0].videoId      || String(Date.now());\n\nconst outDir  = `/home/node/download/${ch}/${vid}`;\nconst outName = `shadow_${vid}.mp4`;\n\nconsole.log(`#DEST_DIR=${outDir}`);\nconsole.log(`#FINAL_OUT=${outDir}/${outName}`);\nconsole.log(`#VIDEO_ID=${vid}`);\nconsole.log(`#CHANNEL_NAME=${ch}`);\n\n// Para cada item, emitimos: audio|texto|scene\nfor (const it of arr) {\n  const scene = it.sceneId ?? 0;\n  const audio = it.videoMetaData?.file || '';\n  const text  = String(it.audioSubtitle ?? '').replace(/\\r?\\n/g, ' ');\n  console.log([audio, text, scene].join('|'));\n}\nJS\n\nTSV_RAW=\"$TMPDIR/raw.tsv\"\nnode \"$BUILD_JS\" \"$IN_JSON\" > \"$TSV_RAW\"\n\nDEST_DIR=$(grep '^#DEST_DIR=' \"$TSV_RAW\" | head -n1 | cut -d'=' -f2-)\nFINAL_OUT=$(grep '^#FINAL_OUT=' \"$TSV_RAW\" | head -n1 | cut -d'=' -f2-)\n[ -n \"$DEST_DIR\" ] || { echo \"Falha ao obter DEST_DIR\"; exit 1; }\nmkdir -p \"$DEST_DIR\"\n\nDATA_FILE=\"$TMPDIR/data.tsv\"\ngrep -v '^#' \"$TSV_RAW\" > \"$DATA_FILE\"\n\n# ================= Loop principal =================\nlast_scene=\"\"; idx=0; read_first_line=1\nexec 9< \"$DATA_FILE\"\nwhile IFS='|' read -r -u 9 SRC TXT SCENE; do\n  # Verifica se há arquivo de áudio e se ele existe\n  if [ -z \"${SRC:-}\" ]; then\n    echo \"AVISO: Linha sem arquivo de áudio (texto: ${TXT:0:50}...)\"\n    continue\n  fi\n  if [ ! -f \"$SRC\" ]; then\n    echo \"ERRO: Arquivo de áudio não encontrado: $SRC\"\n    echo \"Verifique se o processo anterior gerou os arquivos corretamente.\"\n    exit 1\n  fi\n  \n  DUR=$(probe_dur \"$SRC\")\n  if [ -z \"$DUR\" ] || [ \"$DUR\" = \"0\" ] || [ \"$DUR\" = \"0.000000\" ]; then\n    echo \"ERRO: Duração inválida para $SRC (dur=$DUR)\"\n    exit 1\n  fi\n\n  # Inter-cena: xfade TOGETHER -> LISTEN\n  if [ \"$read_first_line\" -eq 0 ] && [ \"$SCENE\" != \"$last_scene\" ]; then\n    XF=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_xfade_scene_${last_scene}_to_${SCENE}.mp4\"\n    make_scene_xfade \"$TOGETHER_IMG\" \"$LISTEN_IMG\" \"$XF\" \"${SCENE_XFADE_SEC:-0.6}\"\n    printf \"file '%s'\\n\" \"$XF\" >> \"$LIST\"; idx=$((idx+1))\n  fi\n  read_first_line=0; last_scene=\"$SCENE\"\n\n  if [ \"$SCENE\" -eq 0 ]; then\n    # ===== Cena 0: apenas UM take, fundo preto (sem 3 repetições) =====\n    P0=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_intro_s0.mp4\"\n    # Passa IMG=\"\" para usar a cor BG_COLOR (preto)\n    make_text_over_audio \"$SRC\" \"$P0\" \"$TXT\" \"\"\n    printf \"file '%s'\\n\" \"$P0\" >> \"$LIST\"; idx=$((idx+1))\n  else\n    # ===== Demais cenas: ciclo fixo LISTEN -> REPEAT -> TOGETHER =====\n\n    # 1) LISTEN: áudio + texto + waveform branca no rodapé (com fade in/out)\n    P1=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_listen_s${SCENE}.mp4\"\n    make_text_over_audio \"$SRC\" \"$P1\" \"$TXT\" \"$LISTEN_IMG\"\n    printf \"file '%s'\\n\" \"$P1\" >> \"$LIST\"; idx=$((idx+1))\n\n    # xfade LISTEN -> REPEAT\n    if [ \"${SCENE_XFADE_SEC:-0.6}\" != \"0\" ]; then\n      X1=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_xfade_listen_to_repeat_s${SCENE}.mp4\"\n      make_scene_xfade \"$LISTEN_IMG\" \"$REPEAT_IMG\" \"$X1\" \"${SCENE_XFADE_SEC:-0.6}\"\n      printf \"file '%s'\\n\" \"$X1\" >> \"$LIST\"; idx=$((idx+1))\n    fi\n\n    # 2) REPEAT: silêncio do tamanho do áudio + texto + COUNTDOWN (com fade in/out de vídeo)\n    PR=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_repeat_s${SCENE}.mp4\"\n    make_silence_with_text \"$PR\" \"$DUR\" \"$TXT\" \"$REPEAT_IMG\"\n    printf \"file '%s'\\n\" \"$PR\" >> \"$LIST\"; idx=$((idx+1))\n\n    # xfade REPEAT -> TOGETHER\n    if [ \"${SCENE_XFADE_SEC:-0.6}\" != \"0\" ]; then\n      X2=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_xfade_repeat_to_together_s${SCENE}.mp4\"\n      make_scene_xfade \"$REPEAT_IMG\" \"$TOGETHER_IMG\" \"$X2\" \"${SCENE_XFADE_SEC:-0.6}\"\n      printf \"file '%s'\\n\" \"$X2\" >> \"$LIST\"; idx=$((idx+1))\n    fi\n\n    # 3) TOGETHER: replay do áudio + texto + waveform (com fade in/out)\n    P3=\"$TMPDIR/part_$(printf \"%03d\" \"$idx\")_together_s${SCENE}.mp4\"\n    make_text_over_audio \"$SRC\" \"$P3\" \"$TXT\" \"$TOGETHER_IMG\"\n    printf \"file '%s'\\n\" \"$P3\" >> \"$LIST\"; idx=$((idx+1))\n  fi\ndone\nexec 9<&-\n\n# Concat final\nffmpeg -nostdin -hide_banner -loglevel error -y -f concat -safe 0 -i \"$LIST\" -c copy -movflags +faststart \"$FINAL_OUT\"\necho \"OK: $FINAL_OUT\"\n"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1200,
        448
      ],
      "id": "2a0424b3-7346-482e-9816-ae8f8a115a4b",
      "name": "LONG - Execute Command with Fixed Image "
    },
    {
      "parameters": {
        "command": "=#!/usr/bin/env bash\nset -Eeuo pipefail\nexport LC_ALL=C\nexport LANG=C\n\n############# CONFIG BASE (perfil PAISAGEM) #############\nSCALE_MODE=\"${SCALE_MODE:-stretch}\"\nCANVAS_W=${CANVAS_W:-1920}\nCANVAS_H=${CANVAS_H:-1080}\nBG_COLOR=\"${BG_COLOR:-black}\"\n\nFONT_ROOT=\"${FONT_ROOT:-/home/node/assets/COMMON/fonts}\"\nFONT_FILE=\"${FONT_FILE:-$FONT_ROOT/impact.ttf}\"\nFONT_NAME=\"${FONT_NAME:-Impact}\"\nFONT_SIZE=${FONT_SIZE:-72}\nSAFE_MARGIN=${SAFE_MARGIN:-72}\n\nTEXT_OUTLINE=\"${TEXT_OUTLINE:-0.6}\"\nTEXT_SHADOW=\"${TEXT_SHADOW:-0.12}\"\n\nEDGE_FADE_SEC=\"${EDGE_FADE_SEC:-0.25}\"\nAUDIO_FADE_SEC=\"${AUDIO_FADE_SEC:-0.12}\"\n\nX264_PRESET=\"${X264_PRESET:-veryfast}\"\nX264_CRF=${X264_CRF:-21}\nAUDIO_BR=\"${AUDIO_BR:-160k}\"\n\nWAVEFORM_ENABLE=\"${WAVEFORM_ENABLE:-1}\"\nWAVEFORM_WIDTH_PCT=\"${WAVEFORM_WIDTH_PCT:-60}\"\nWAVEFORM_HEIGHT=\"${WAVEFORM_HEIGHT:-200}\"\nWAVEFORM_OPACITY=\"${WAVEFORM_OPACITY:-0.95}\"\nWAVEFORM_MARGIN_BOTTOM=\"${WAVEFORM_MARGIN_BOTTOM:-12}\"\nWAVEFORM_MODE=\"${WAVEFORM_MODE:-bar}\"\n\nCOUNTDOWN_ENABLE=\"${COUNTDOWN_ENABLE:-1}\"\nCOUNTDOWN_HEIGHT=\"${COUNTDOWN_HEIGHT:-20}\"\nCOUNTDOWN_MARGIN_BOTTOM=\"${COUNTDOWN_MARGIN_BOTTOM:-50}\"\nCOUNTDOWN_BG_COLOR=\"${COUNTDOWN_BG_COLOR:-333333}\"\n\nBASE_BG_DIR=\"${BASE_BG_DIR:-/home/node/assets/CANAL_SHADOWING}\"\nLISTEN_IMG=\"${LISTEN_IMG:-$BASE_BG_DIR/listen01.png}\"\nREPEAT_IMG=\"${REPEAT_IMG:-$BASE_BG_DIR/repeat01.png}\"\nTOGETHER_IMG=\"${TOGETHER_IMG:-$BASE_BG_DIR/talk-together01.png}\"\nSCENE_XFADE_SEC=\"${SCENE_XFADE_SEC:-0.6}\"\n\n########## CONFIG (perfil SHORTS – vertical) ##########\nSHORTS_CANVAS_W=\"${SHORTS_CANVAS_W:-1080}\"\nSHORTS_CANVAS_H=\"${SHORTS_CANVAS_H:-1920}\"\nSHORTS_FONT_SIZE=\"${SHORTS_FONT_SIZE:-80}\"\nSHORTS_SAFE_MARGIN=\"${SHORTS_SAFE_MARGIN:-80}\"\nSHORTS_WAVEFORM_WIDTH_PCT=\"${SHORTS_WAVEFORM_WIDTH_PCT:-90}\"\nSHORTS_WAVEFORM_HEIGHT=\"${SHORTS_WAVEFORM_HEIGHT:-220}\"\nSHORTS_WAVEFORM_MARGIN_BOTTOM=\"${SHORTS_WAVEFORM_MARGIN_BOTTOM:-24}\"\nSHORTS_COUNTDOWN_HEIGHT=\"${SHORTS_COUNTDOWN_HEIGHT:-24}\"\nSHORTS_COUNTDOWN_MARGIN_BOTTOM=\"${SHORTS_COUNTDOWN_MARGIN_BOTTOM:-96}\"\nSHORTS_SCALE_MODE=\"${SHORTS_SCALE_MODE:-cover}\"\nSHORTS_SCENE_XFADE_SEC=\"${SHORTS_SCENE_XFADE_SEC:-0.45}\"\n\n# Quais passes incluir em cada Short (listen | listen_repeat | listen_together | full)\nSHORTS_PASSES=\"${SHORTS_PASSES:-full}\"\n\n# Limite e fade dos shorts\nMAX_DURATION_SHORTS=\"${MAX_DURATION_SHORTS:-175}\"\nFADE_OUT_SHORTS_SEC=\"${FADE_OUT_SHORTS_SEC:-2}\"\n\n# Dependências básicas\nfor bin in ffmpeg ffprobe node; do\n  command -v \"$bin\" >/dev/null 2>&1 || { echo \"ERRO: $bin não encontrado no PATH\"; exit 1; }\ndone\n\n# Snapshot dos valores de LANDSCAPE (usados pelo set_profile)\n__LAND_CANVAS_W=\"$CANVAS_W\"\n__LAND_CANVAS_H=\"$CANVAS_H\"\n__LAND_FONT_SIZE=\"$FONT_SIZE\"\n__LAND_SAFE_MARGIN=\"$SAFE_MARGIN\"\n__LAND_WF_WPCT=\"$WAVEFORM_WIDTH_PCT\"\n__LAND_WF_H=\"$WAVEFORM_HEIGHT\"\n__LAND_WF_MB=\"$WAVEFORM_MARGIN_BOTTOM\"\n__LAND_CD_H=\"$COUNTDOWN_HEIGHT\"\n__LAND_CD_MB=\"$COUNTDOWN_MARGIN_BOTTOM\"\n__LAND_SCALE_MODE=\"$SCALE_MODE\"\n__LAND_SCENE_XF=\"$SCENE_XFADE_SEC\"\n\nset_profile() {\n  case \"$1\" in\n    LANDSCAPE)\n      CANVAS_W=\"$__LAND_CANVAS_W\"\n      CANVAS_H=\"$__LAND_CANVAS_H\"\n      FONT_SIZE=\"$__LAND_FONT_SIZE\"\n      SAFE_MARGIN=\"$__LAND_SAFE_MARGIN\"\n      WAVEFORM_WIDTH_PCT=\"$__LAND_WF_WPCT\"\n      WAVEFORM_HEIGHT=\"$__LAND_WF_H\"\n      WAVEFORM_MARGIN_BOTTOM=\"$__LAND_WF_MB\"\n      COUNTDOWN_HEIGHT=\"$__LAND_CD_H\"\n      COUNTDOWN_MARGIN_BOTTOM=\"$__LAND_CD_MB\"\n      SCALE_MODE=\"$__LAND_SCALE_MODE\"\n      SCENE_XFADE_SEC=\"$__LAND_SCENE_XF\"\n      ;;\n    SHORTS)\n      CANVAS_W=\"$SHORTS_CANVAS_W\"\n      CANVAS_H=\"$SHORTS_CANVAS_H\"\n      FONT_SIZE=\"$SHORTS_FONT_SIZE\"\n      SAFE_MARGIN=\"$SHORTS_SAFE_MARGIN\"\n      WAVEFORM_WIDTH_PCT=\"$SHORTS_WAVEFORM_WIDTH_PCT\"\n      WAVEFORM_HEIGHT=\"$SHORTS_WAVEFORM_HEIGHT\"\n      WAVEFORM_MARGIN_BOTTOM=\"$SHORTS_WAVEFORM_MARGIN_BOTTOM\"\n      COUNTDOWN_HEIGHT=\"$SHORTS_COUNTDOWN_HEIGHT\"\n      COUNTDOWN_MARGIN_BOTTOM=\"$SHORTS_COUNTDOWN_MARGIN_BOTTOM\"\n      SCALE_MODE=\"$SHORTS_SCALE_MODE\"\n      SCENE_XFADE_SEC=\"$SHORTS_SCENE_XFADE_SEC\"\n      ;;\n  esac\n  export CANVAS_W CANVAS_H FONT_SIZE SAFE_MARGIN \\\n         WAVEFORM_WIDTH_PCT WAVEFORM_HEIGHT WAVEFORM_MARGIN_BOTTOM \\\n         COUNTDOWN_HEIGHT COUNTDOWN_MARGIN_BOTTOM SCALE_MODE SCENE_XFADE_SEC\n}\n\n# Área de trabalho temporária\nTMPROOT=\"/home/node/download\"\nmkdir -p \"$TMPROOT\"\nTMPDIR=\"$(mktemp -d \"$TMPROOT/.shadow_XXXXXX\")\"\ntrap 'rm -rf \"$TMPDIR\"' EXIT\n\n# Fonte: fallback e nome interno\nif [ ! -f \"$FONT_FILE\" ]; then\n  if   [ -f \"$FONT_ROOT/impact.ttf\" ]; then FONT_FILE=\"$FONT_ROOT/impact.ttf\"\n  elif [ -f \"$FONT_ROOT/Impact.ttf\" ]; then FONT_FILE=\"$FONT_ROOT/Impact.ttf\"\n  elif [ -f \"$FONT_ROOT/Impact.otf\" ]; then FONT_FILE=\"$FONT_ROOT/Impact.otf\"\n  fi\nfi\nFONT_DIR=\"$(dirname \"$FONT_FILE\")\"\nif command -v fc-scan >/dev/null 2>&1; then\n  INTERNAL_NAME=\"$(fc-scan --format='%{family}\\n' \"$FONT_FILE\" 2>/dev/null | head -n1 || true)\"\n  [ -n \"$INTERNAL_NAME\" ] && FONT_NAME=\"$INTERNAL_NAME\"\nfi\nFONTS_ESC=\"$FONT_DIR\"\nFONTS_ESC=\"${FONTS_ESC//\\\\/\\\\\\\\}\"\nFONTS_ESC=\"${FONTS_ESC//:/\\\\:}\"\nFONTS_ESC=\"${FONTS_ESC// /\\\\ }\"\n\n# Helpers\nclamp_start () { awk -v d=\"$1\" -v f=\"$2\" 'BEGIN{ s=d-f; if (s<0) s=0; printf \"%.3f\", s }'; }\nprobe_dur () { ffprobe -hide_banner -loglevel error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 \"$1\" 2>/dev/null | tr -d '\\r' || true; }\nscale_to_canvas () {\n  case \"$SCALE_MODE\" in\n    cover)   echo \"scale=${CANVAS_W}:${CANVAS_H}:force_original_aspect_ratio=increase,crop=${CANVAS_W}:${CANVAS_H}\" ;;\n    stretch) echo \"scale=${CANVAS_W}:${CANVAS_H}\" ;;\n    *)       echo \"scale=${CANVAS_W}:${CANVAS_H}:force_original_aspect_ratio=decrease,pad=${CANVAS_W}:${CANVAS_H}:(ow-iw)/2:(oh-ih)/2:color=${BG_COLOR}\" ;;\n  esac\n}\n\nmake_ass_file () {\n  local ASS=\"$1\" RAW=\"$2\" SAN TXT STYLE_OVERRIDE\n  SAN=\"$RAW\"\n  SAN=\"${SAN//\\\\/\\\\\\\\}\"\n  SAN=\"${SAN//\\{/(}\"\n  SAN=\"${SAN//\\}/)}\"\n  STYLE_OVERRIDE=\"{\\fn${FONT_NAME}\\bord${TEXT_OUTLINE}\\shad${TEXT_SHADOW}\\b0}\"\n  TXT=\"${STYLE_OVERRIDE}${SAN}\"\n\n  cat > \"$ASS\" <<EOF\n[Script Info]\nScriptType: v4.00+\nPlayResX: ${CANVAS_W}\nPlayResY: ${CANVAS_H}\nScaledBorderAndShadow: yes\nWrapStyle: 0\n\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Default, ${FONT_NAME}, ${FONT_SIZE}, &H00FFFFFF, &H000000FF, &H00404040, &H00000000, 0, 0, 0, 0, 100, 100, 0, 0, 1, ${TEXT_OUTLINE}, ${TEXT_SHADOW}, 5, ${SAFE_MARGIN}, ${SAFE_MARGIN}, ${SAFE_MARGIN}, 0\n\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\nDialogue: 0,0:00:00.00,9:59:59.99,Default,,0000,0000,0000,,${TXT}\nEOF\n}\n\nmake_text_over_audio () {\n  local SRC=\"$1\" OUT=\"$2\" TXT=\"$3\" IMG=\"$4\" DUR ASSF\n  DUR=$(probe_dur \"$SRC\"); [ -z \"$DUR\" ] && DUR=0\n  ASSF=\"$OUT.ass\"; make_ass_file \"$ASSF\" \"$TXT\"\n\n  local VOUT_ST; VOUT_ST=$(clamp_start \"$DUR\" \"$EDGE_FADE_SEC\")\n  local AOUT_ST; AOUT_ST=$(clamp_start \"$DUR\" \"$AUDIO_FADE_SEC\")\n\n  local WF_W=$(( CANVAS_W * ${WAVEFORM_WIDTH_PCT:-60} / 100 ))\n  local WF_H=${WAVEFORM_HEIGHT:-200}\n  local REQ_MODE=\"${WAVEFORM_MODE:-bar}\"\n  local SW_MODE=\"line\"\n  local THICK_MUL=3; [ \"$REQ_MODE\" = \"line\" ] && THICK_MUL=1\n  local WF_HI=$(( WF_H * THICK_MUL ))\n\n  local WF_CHAIN=\"\"\n  if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n    WF_CHAIN=\"[0:a]showwaves=s=${WF_W}x${WF_HI}:mode=${SW_MODE}:colors=white,format=rgba,colorkey=black:similarity=0.01:blend=0,scale=${WF_W}x${WF_H},colorchannelmixer=aa=${WAVEFORM_OPACITY:-0.95}[wv];\"\n  fi\n\n  local OVERLAY_EXPR=\"x=(W-w)/2:y=H-${WAVEFORM_MARGIN_BOTTOM:-12}-h\"\n\n  if [ -n \"${IMG:-}\" ] && [ -f \"$IMG\" ]; then\n    if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n        -filter_complex \"\\\n[1:v]$(scale_to_canvas)[bg];\\\n[bg]ass='${ASSF}':shaping=1:fontsdir=${FONTS_ESC}[txt];\\\n${WF_CHAIN}\\\n[txt][wv]overlay=${OVERLAY_EXPR},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    else\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n        -filter_complex \"\\\n[1:v]$(scale_to_canvas)[bg];\\\n[bg]ass='${ASSF}':shaping=1:fontsdir=${FONTS_ESC},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    fi\n  else\n    if [ \"${WAVEFORM_ENABLE:-1}\" -eq 1 ]; then\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n        -filter_complex \"\\\n[1:v]ass='${ASSF}':shaping=1:fontsdir=${FONTS_ESC}[bg];\\\n${WF_CHAIN}\\\n[bg][wv]overlay=${OVERLAY_EXPR},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    else\n      ffmpeg -nostdin -hide_banner -loglevel error -y \\\n        -i \"$SRC\" -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n        -filter_complex \"\\\n[1:v]ass='${ASSF}':shaping=1:fontsdir=${FONTS_ESC},fade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,fps=30,setsar=1[v];\\\n[0:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n        -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF \\\n        -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n    fi\n  fi\n}\n\nmake_silence_with_text () {\n  local OUT=\"$1\" DUR=\"$2\" TXT=\"$3\" IMG=\"$4\" ASSF\n  ASSF=\"$OUT.ass\"; make_ass_file \"$ASSF\" \"$TXT\"\n\n  local VOUT_ST; VOUT_ST=$(clamp_start \"$DUR\" \"$EDGE_FADE_SEC\")\n  local AOUT_ST; AOUT_ST=$(clamp_start \"$DUR\" \"$AUDIO_FADE_SEC\")\n\n  local BAR_H=\"${COUNTDOWN_HEIGHT:-20}\"\n  local BAR_MARGIN=\"${COUNTDOWN_MARGIN_BOTTOM:-50}\"\n  local BAR_W=$((CANVAS_W - 200))\n  local BAR_X=100\n  local BAR_Y=$((CANVAS_H - BAR_MARGIN - BAR_H))\n\n  local COUNTDOWN_FILTER=\"\"\n  if [ \"${COUNTDOWN_ENABLE:-1}\" -eq 1 ]; then\n    COUNTDOWN_FILTER=\"\\\ncolor=c=white:size=${BAR_W}x${BAR_H}:rate=30:duration=${DUR},format=rgba,\\\ngeq=r='255':g='255':b='255':a='if(lte(X, W*max(1 - T/${DUR}, 0)), 255, 0)'[bar];\\\n[txt]drawbox=x=${BAR_X}:y=${BAR_Y}:w=${BAR_W}:h=${BAR_H}:color=0x${COUNTDOWN_BG_COLOR}:t=fill[txtbg];\\\n[txtbg][bar]overlay=${BAR_X}:${BAR_Y},\"\n  fi\n\n  if [ -n \"${IMG:-}\" ] && [ -f \"$IMG\" ]; then\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -loop 1 -t \"$DUR\" -i \"$IMG\" \\\n      -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"\\\n[0:v]$(scale_to_canvas)[bg];\\\n[bg]ass='${ASSF}':shaping=1:fontsdir=${FONTS_ESC},fps=30,setpts=PTS-STARTPTS[txt];\\\n${COUNTDOWN_FILTER}\\\nfade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,setsar=1[v];\\\n[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n      -map \"[v]\" -map \"[a]\" \\\n      -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart \\\n      -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  else\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -f lavfi -t \"$DUR\" -i \"color=size=${CANVAS_W}x${CANVAS_H}:rate=30:color=${BG_COLOR}\" \\\n      -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n      -filter_complex \"\\\n[0:v]ass='${ASSF}':shaping=1:fontsdir=${FONTS_ESC},fps=30,setpts=PTS-STARTPTS[txt];\\\n${COUNTDOWN_FILTER}\\\nfade=t=in:st=0:d=${EDGE_FADE_SEC},fade=t=out:st=${VOUT_ST}:d=${EDGE_FADE_SEC},format=yuv420p,setsar=1[v];\\\n[1:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo,afade=t=in:st=0:d=${AUDIO_FADE_SEC},afade=t=out:st=${AOUT_ST}:d=${AUDIO_FADE_SEC}[a]\" \\\n      -map \"[v]\" -map \"[a]\" \\\n      -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart \\\n      -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n  fi\n}\n\nmake_scene_xfade () {\n  local P=\"$1\" N=\"$2\" OUT=\"$3\" DUR=\"$4\"\n  ffmpeg -nostdin -hide_banner -loglevel error -y \\\n    -loop 1 -t \"$DUR\" -i \"$P\" -loop 1 -t \"$DUR\" -i \"$N\" -f lavfi -t \"$DUR\" -i \"anullsrc=channel_layout=stereo:sample_rate=44100\" \\\n    -filter_complex \"[0:v]$(scale_to_canvas)[a0];[1:v]$(scale_to_canvas)[a1];[a0][a1]xfade=transition=fade:duration=${DUR}:offset=0,format=yuv420p,setsar=1,fps=30[v];[2:a]aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo[a]\" \\\n    -map \"[v]\" -map \"[a]\" -c:v libx264 -preset \"$X264_PRESET\" -crf $X264_CRF -pix_fmt yuv420p -movflags +faststart -c:a aac -b:a \"$AUDIO_BR\" -shortest \"$OUT\"\n}\n\n# ---------- Entrada do n8n (JSON como array) ----------\nIN_JSON=\"$TMPDIR/in.json\"\ncat > \"$IN_JSON\" <<'JSON'\n{{ JSON.stringify($input.all().map(i => i.json)) }}\nJSON\n[ -s \"$IN_JSON\" ] || { echo \"ERRO: Entrada JSON vazia\"; exit 1; }\n\n# ---------- Builder: extrai canal, videoId e linhas (audio|texto|sceneId) ----------\nBUILD_JS=\"$TMPDIR/build.js\"\ncat > \"$BUILD_JS\" <<'JS'\nconst fs = require('fs');\nconst env = process.env;\nconst path = process.argv[2];\n\nlet arr;\ntry { arr = JSON.parse(fs.readFileSync(path, 'utf8')); }\ncatch(e){ console.error('JSON inválido:', e.message); process.exit(2); }\n\nif (!Array.isArray(arr) || !arr.length) { console.error('JSON vazio'); process.exit(3); }\n\nconst ch  = env.CHANNEL_NAME || arr[0].CHANNEL_NAME || 'CANAL_SHADOWING';\nconst vid = env.VIDEO_ID     || arr[0].videoId      || String(Date.now());\n\nconst outDir  = `/home/node/download/${ch}/${vid}`;\n\nconsole.log(`#DEST_DIR=${outDir}`);\nconsole.log(`#VIDEO_ID=${vid}`);\nconsole.log(`#CHANNEL_NAME=${ch}`);\n\nfor (const it of arr) {\n  const scene = it.sceneId ?? 0;\n  const audio = it.videoMetaData?.file || '';\n  const text  = String(it.audioSubtitle ?? '')\n                  .replace(/\\r?\\n/g, ' ')\n                  .replace(/\\|/g, '¦');\n  console.log([audio, text, scene].join('|'));\n}\nJS\n\nTSV_RAW=\"$TMPDIR/raw.tsv\"\nnode \"$BUILD_JS\" \"$IN_JSON\" > \"$TSV_RAW\"\n\nDEST_DIR=$(grep '^#DEST_DIR=' \"$TSV_RAW\" | head -n1 | cut -d'=' -f2-)\nVIDEO_ID=$(grep '^#VIDEO_ID=' \"$TSV_RAW\" | head -n1 | cut -d'=' -f2-)\nCHANNEL_NAME=$(grep '^#CHANNEL_NAME=' \"$TSV_RAW\" | head -n1 | cut -d'=' -f2-)\n\n[ -n \"$DEST_DIR\" ] || { echo \"Falha ao obter DEST_DIR\"; exit 1; }\nmkdir -p \"$DEST_DIR\"\nexport VIDEO_ID CHANNEL_NAME\n\necho \"=== VARIÁVEIS EXTRAÍDAS ===\"\necho \"CHANNEL_NAME: $CHANNEL_NAME\"\necho \"VIDEO_ID: $VIDEO_ID\"\necho \"DEST_DIR: $DEST_DIR\"\necho \"===========================\"\n\nDATA_FILE=\"$TMPDIR/data.tsv\"\ngrep -v '^#' \"$TSV_RAW\" > \"$DATA_FILE\"\n\n############################\n# ========= SHORTS =========\n############################\nset_profile SHORTS\n\n# Intro opcional (sceneId = 0)\nINTRO_AUDIO_SRC=\"\"\nINTRO_TXT=\"\"\nif awk -F'|' '$3==\"0\"{exit 0} END{exit 1}' \"$DATA_FILE\"; then\n  while IFS='|' read -r SRC TXT SCENE; do\n    [ \"${SCENE:-}\" = \"0\" ] || continue\n    INTRO_AUDIO_SRC=\"$SRC\"\n    INTRO_TXT=\"$TXT\"\n    break\n  done < \"$DATA_FILE\"\nfi\n\nSHORT_INTRO=\"\"\nif [ -n \"${INTRO_AUDIO_SRC:-}\" ] && [ -f \"$INTRO_AUDIO_SRC\" ]; then\n  SHORT_INTRO=\"$TMPDIR/short_intro_v.mp4\"\n  make_text_over_audio \"$INTRO_AUDIO_SRC\" \"$SHORT_INTRO\" \"$INTRO_TXT\" \"\"\nelse\n  echo \"AVISO: Não foi encontrada cena de introdução (sceneId=0). Shorts: sem intro.\"\nfi\n\n# Conjunto de cenas > 0\nSCENES=$(awk -F'|' '$3!=\"\" && $3!=\"0\"{print $3}' \"$DATA_FILE\" | sort -n | uniq || true)\n\nfor S in $SCENES; do\n  LIST_S=\"$TMPDIR/list_short_s${S}.txt\"; : > \"$LIST_S\"\n\n  [ -n \"$SHORT_INTRO\" ] && [ -f \"$SHORT_INTRO\" ] && printf \"file '%s'\\n\" \"$SHORT_INTRO\" >> \"$LIST_S\"\n\n  while IFS='|' read -r SRC TXT SCENE; do\n    [ \"${SCENE:-}\" != \"$S\" ] && continue\n\n    if [ -z \"${SRC:-}\" ] || [ ! -f \"$SRC\" ]; then\n      echo \"AVISO: Áudio ausente para cena $S (SRC='$SRC')\"\n      continue\n    fi\n\n    DUR=$(probe_dur \"$SRC\"); [ -z \"$DUR\" ] && DUR=0\n    [ \"$DUR\" = \"0\" ] && { echo \"AVISO: duração zero em $SRC\"; continue; }\n\n    case \"$SHORTS_PASSES\" in\n      listen)\n        A=\"$TMPDIR/short_s${S}_listen_$(basename \"$SRC\").mp4\"\n        make_text_over_audio \"$SRC\" \"$A\" \"$TXT\" \"$LISTEN_IMG\"\n        printf \"file '%s'\\n\" \"$A\" >> \"$LIST_S\"\n        ;;\n      listen_repeat)\n        A=\"$TMPDIR/short_s${S}_listen_$(basename \"$SRC\").mp4\"\n        make_text_over_audio \"$SRC\" \"$A\" \"$TXT\" \"$LISTEN_IMG\"\n        printf \"file '%s'\\n\" \"$A\" >> \"$LIST_S\"\n        if [ \"${SCENE_XFADE_SEC:-0.45}\" != \"0\" ]; then\n          X=\"$TMPDIR/short_s${S}_xfade_l2r_$(basename \"$SRC\").mp4\"\n          make_scene_xfade \"$LISTEN_IMG\" \"$REPEAT_IMG\" \"$X\" \"${SCENE_XFADE_SEC:-0.45}\"\n          printf \"file '%s'\\n\" \"$X\" >> \"$LIST_S\"\n        fi\n        B=\"$TMPDIR/short_s${S}_repeat_$(basename \"$SRC\").mp4\"\n        make_silence_with_text \"$B\" \"$DUR\" \"$TXT\" \"$REPEAT_IMG\"\n        printf \"file '%s'\\n\" \"$B\" >> \"$LIST_S\"\n        ;;\n      listen_together)\n        A=\"$TMPDIR/short_s${S}_listen_$(basename \"$SRC\").mp4\"\n        make_text_over_audio \"$SRC\" \"$A\" \"$TXT\" \"$LISTEN_IMG\"\n        printf \"file '%s'\\n\" \"$A\" >> \"$LIST_S\"\n        if [ \"${SCENE_XFADE_SEC:-0.45}\" != \"0\" ]; then\n          X=\"$TMPDIR/short_s${S}_xfade_l2t_$(basename \"$SRC\").mp4\"\n          make_scene_xfade \"$LISTEN_IMG\" \"$TOGETHER_IMG\" \"$X\" \"${SCENE_XFADE_SEC:-0.45}\"\n          printf \"file '%s'\\n\" \"$X\" >> \"$LIST_S\"\n        fi\n        C=\"$TMPDIR/short_s${S}_together_$(basename \"$SRC\").mp4\"\n        make_text_over_audio \"$SRC\" \"$C\" \"$TXT\" \"$TOGETHER_IMG\"\n        printf \"file '%s'\\n\" \"$C\" >> \"$LIST_S\"\n        ;;\n      full|*)\n        A=\"$TMPDIR/short_s${S}_listen_$(basename \"$SRC\").mp4\"\n        make_text_over_audio \"$SRC\" \"$A\" \"$TXT\" \"$LISTEN_IMG\"\n        printf \"file '%s'\\n\" \"$A\" >> \"$LIST_S\"\n\n        if [ \"${SCENE_XFADE_SEC:-0.45}\" != \"0\" ]; then\n          X1=\"$TMPDIR/short_s${S}_xfade_l2r_$(basename \"$SRC\").mp4\"\n          make_scene_xfade \"$LISTEN_IMG\" \"$REPEAT_IMG\" \"$X1\" \"${SCENE_XFADE_SEC:-0.45}\"\n          printf \"file '%s'\\n\" \"$X1\" >> \"$LIST_S\"\n        fi\n\n        B=\"$TMPDIR/short_s${S}_repeat_$(basename \"$SRC\").mp4\"\n        make_silence_with_text \"$B\" \"$DUR\" \"$TXT\" \"$REPEAT_IMG\"\n        printf \"file '%s'\\n\" \"$B\" >> \"$LIST_S\"\n\n        if [ \"${SCENE_XFADE_SEC:-0.45}\" != \"0\" ]; then\n          X2=\"$TMPDIR/short_s${S}_xfade_r2t_$(basename \"$SRC\").mp4\"\n          make_scene_xfade \"$REPEAT_IMG\" \"$TOGETHER_IMG\" \"$X2\" \"${SCENE_XFADE_SEC:-0.45}\"\n          printf \"file '%s'\\n\" \"$X2\" >> \"$LIST_S\"\n        fi\n\n        C=\"$TMPDIR/short_s${S}_together_$(basename \"$SRC\").mp4\"\n        make_text_over_audio \"$SRC\" \"$C\" \"$TXT\" \"$TOGETHER_IMG\"\n        printf \"file '%s'\\n\" \"$C\" >> \"$LIST_S\"\n        ;;\n    esac\n  done < \"$DATA_FILE\"\n\n  OUT_SHORT=\"/home/node/download/${CHANNEL_NAME}/${VIDEO_ID}/short_${S}_${VIDEO_ID}.mp4\"\n  mkdir -p \"$(dirname \"$OUT_SHORT\")\"\n  ffmpeg -nostdin -hide_banner -loglevel error -y -f concat -safe 0 -i \"$LIST_S\" -c copy -movflags +faststart \"$OUT_SHORT\"\n  echo \"OK_SHORT_SCENE_${S}: $OUT_SHORT\"\n\n  # Trim+fade se exceder o limite\n  get_dur() { ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 \"$1\" 2>/dev/null | awk '{printf \"%.3f\", $1}'; }\n  SHORT_DUR=\"$(get_dur \"$OUT_SHORT\" || echo 0)\"\n  echo \"Dur. Short s${S}: ${SHORT_DUR}s\"\n  NEEDS_TRIM_S=\"$(awk -v d=\"$SHORT_DUR\" -v m=\"$MAX_DURATION_SHORTS\" 'BEGIN{print (d>m)?1:0}')\"\n  if [ \"$NEEDS_TRIM_S\" = \"1\" ]; then\n    FADE_ST_S=\"$(awk -v m=\"$MAX_DURATION_SHORTS\" -v f=\"$FADE_OUT_SHORTS_SEC\" 'BEGIN{s=m-f; if(s<0) s=0; printf \"%.3f\", s}')\"\n    TMP_TRIM_S=\"$TMPDIR/short_${S}_${VIDEO_ID}_trimmed.mp4\"\n    echo \"Aplicando fade-out de ${FADE_OUT_SHORTS_SEC}s a partir de ${FADE_ST_S}s e cortando em ${MAX_DURATION_SHORTS}s…\"\n\n    ffmpeg -nostdin -hide_banner -loglevel error -y \\\n      -i \"$OUT_SHORT\" \\\n      -vf \"fade=type=out:start_time=${FADE_ST_S}:duration=${FADE_OUT_SHORTS_SEC}\" \\\n      -af \"afade=type=out:start_time=${FADE_ST_S}:duration=${FADE_OUT_SHORTS_SEC}\" \\\n      -t \"$MAX_DURATION_SHORTS\" \\\n      -c:v libx264 -preset \"$X264_PRESET\" -crf \"$X264_CRF\" \\\n      -c:a aac -b:a \"$AUDIO_BR\" \\\n      -pix_fmt yuv420p -movflags +faststart \\\n      \"$TMP_TRIM_S\"\n\n    mv -f \"$TMP_TRIM_S\" \"$OUT_SHORT\"\n    echo \"OK (trim+fade Short s${S}): $OUT_SHORT\"\n  else\n    echo \"Short s${S} <= ${MAX_DURATION_SHORTS}s, sem ajuste.\"\n  fi\ndone\n\necho \"\"\necho \"==========================================\"\necho \"PROCESSAMENTO DE SHORTS CONCLUÍDO!\"\necho \"==========================================\"\necho \"CHANNEL_NAME: $CHANNEL_NAME\"\necho \"VIDEO_ID: $VIDEO_ID\"\necho \"Shorts gerados em: /home/node/download/${CHANNEL_NAME}/${VIDEO_ID}/\"\necho \"==========================================\"\n"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1200,
        240
      ],
      "id": "ccac43e8-7b72-4140-a45b-01d6415c0e44",
      "name": "SHORT - Execute Command with Fixed Image"
    },
    {
      "parameters": {
        "fieldsToAggregate": {
          "fieldToAggregate": [
            {
              "fieldToAggregate": "output"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1648,
        96
      ],
      "id": "fcee34f0-ec2a-4020-b5ee-0abb26963c89",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "0gGqIL1d0xVKVFJl",
          "mode": "list",
          "cachedResultUrl": "/workflow/0gGqIL1d0xVKVFJl",
          "cachedResultName": "@STUDY_CONTENT_MATERIAL"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "theme": "={{ $('START').item.json.theme }}",
            "level": "={{ $('START').item.json.level }}",
            "output": "={{ $json.output }}",
            "videoId": "={{ $('Get videoId from timestamp').item.json.videoId }}",
            "CHANNEL_NAME": "={{ $('@GLOBAL_SHADOWING').item.json.CHANNEL_NAME }}"
          },
          "matchingColumns": [
            "theme",
            "level",
            "output",
            "videoId",
            "CHANNEL_NAME"
          ],
          "schema": [
            {
              "id": "theme",
              "displayName": "theme",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "level",
              "displayName": "level",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "output",
              "displayName": "output",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "videoId",
              "displayName": "videoId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "CHANNEL_NAME",
              "displayName": "CHANNEL_NAME",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        784,
        -240
      ],
      "name": "@STUDY_CONTENT_MATERIAL",
      "id": "83def69e-3013-44e1-ba6b-68b448e5d9e5"
    }
  ],
  "connections": {
    "START": {
      "main": [
        [
          {
            "node": "@GLOBAL_SHADOWING",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@CONTENT_GENERATION": {
      "main": [
        [
          {
            "node": "@YOUTUBE_DATA_CONTENT",
            "type": "main",
            "index": 0
          },
          {
            "node": "@FORMAT_TEXT_GENERATION",
            "type": "main",
            "index": 0
          },
          {
            "node": "@STUDY_CONTENT_MATERIAL",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Content": {
      "main": [
        [
          {
            "node": "@SCENE_METADATA_MAPPER",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "@CONTENT_SHADOWING_GENERATOR_WITHOUT_IMAGES",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@GLOBAL_SHADOWING": {
      "main": [
        [
          {
            "node": "Get videoId from timestamp",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@CONTENT_SHADOWING_GENERATOR": {
      "main": [
        []
      ]
    },
    "Get videoId from timestamp": {
      "main": [
        [
          {
            "node": "@CONTENT_GENERATION",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@SCENE_METADATA_MAPPER": {
      "main": [
        [
          {
            "node": "SHORT - Execute Command with Fixed Image",
            "type": "main",
            "index": 0
          },
          {
            "node": "LONG - Execute Command with Fixed Image ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@CONTENT_SHADOWING_GENERATOR_WITHOUT_IMAGES": {
      "main": [
        [
          {
            "node": "Loop Over Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@FORMAT_TEXT_GENERATION": {
      "main": [
        [
          {
            "node": "Loop Over Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@YOUTUBE_DATA_CONTENT": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "@SHADOWING-THUMBNAIL-CREATOR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LONG - Execute Command with Fixed Image ": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "SHORT - Execute Command with Fixed Image": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "@UPLOAD_YOUTUBE_SHADOWING",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "@STUDY_CONTENT_MATERIAL": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {
    "START": [
      {
        "json": {
          "theme": "So neither either too enough",
          "duration": 3,
          "level": "B2",
          "mode": "Tech Interview (Collaboration): Neither frontend nor backend owned the contract, so how did you define API boundaries",
          "imageStyle": "",
          "scenes": 4,
          "targetWordsPerParagraph": 40
        }
      }
    ]
  },
  "versionId": "17929315-5c73-4e93-a1ac-2ad53c740b35",
  "versionCounter": 80,
  "triggerCount": 0,
  "shared": [
    {
      "updatedAt": "2025-10-16T23:15:45.897Z",
      "createdAt": "2025-10-16T23:15:45.897Z",
      "role": "workflow:owner",
      "workflowId": "7vcjG51SdGRjGJbx",
      "projectId": "TH7SrF7Rx9ho2z9i",
      "project": {
        "updatedAt": "2025-08-20T20:53:20.326Z",
        "createdAt": "2025-08-20T20:52:17.088Z",
        "id": "TH7SrF7Rx9ho2z9i",
        "name": "Hugo Dutra <hugo.dutra@hotmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "updatedAt": "2025-08-20T20:52:17.089Z",
            "createdAt": "2025-08-20T20:52:17.089Z",
            "userId": "96b62bee-ebb1-4fe5-a51b-c116ef7064eb",
            "projectId": "TH7SrF7Rx9ho2z9i",
            "user": {
              "updatedAt": "2026-01-15T11:12:49.000Z",
              "createdAt": "2025-08-20T20:52:15.066Z",
              "id": "96b62bee-ebb1-4fe5-a51b-c116ef7064eb",
              "email": "hugo.dutra@hotmail.com",
              "firstName": "Hugo",
              "lastName": "Dutra",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-08-20T20:56:08.200Z",
                "personalization_survey_n8n_version": "1.107.4",
                "automationGoalDevops": [
                  "other"
                ],
                "automationGoalDevopsOther": "Video As A Service",
                "companySize": "<20",
                "companyType": "saas",
                "role": "engineering",
                "reportedSource": "youtube"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "DOfnd0M834V8kbv2",
                "userActivatedAt": 1755725592234,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1757188846991
                },
                "easyAIWorkflowOnboarded": true,
                "dismissedCallouts": {
                  "preBuiltAgentsCalloutHttpRequest": true,
                  "preBuiltAgentsModalCallout": true
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-01-15",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": []
}